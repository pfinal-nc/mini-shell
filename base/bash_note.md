
bash 解释器就是用来解释shell 语言的程序

元字符

被shell 解释器解释的特殊字符, 元字符是属于shell编程语言的语法

元字符存在可以让命令更加丰富

如何使用元字符

~: 表示家目录

cd ~

&: 后台运行

vim a.txt & # 不在前台展示而是在后台运行, 可以实现多条命令的并发效果

``: 获取命令的执行结果

a=`pwd` # 将pwd命令执行结果复制给a变量

$ :获取变量的值
$a # 获取变量值

$(): 获取命令的执行结果

echo $(ls $(pwd))

!$ :上一条命令的参数

!  : 对命令的结果取反
echo $? 查看命令的执行结果,零表示成功, 非零表示失败
pwd;echo $? ;用于连接命令,先执行第一个命令再执行第二个命令

[]: 取值,中括号表示匹配伊戈尔字符,可以写一个范围,在范围内取值
ls [1234].txt  匹配1 2 3 4 中的任意一个
ls [1-9].txt   匹配1-9中的任意一个
ls [a-z].txt   匹配a-z和A-Z中的任意一个
ls [!1-9].txt  !取反, 匹配一个不是0-9的字符

+ - * / %  加减乘除 取余

以下四种斗殴可以进行运算操作, 但是都不能进行浮点数运算:

$[]
$[1+2] $[$a+3]

$(())  # 和$[]使用方式一样

expr # 注意运算符两侧一定要有空格
expr $q + 1



() 表示在子shell中也就是在子进程中运行命令 不需要通过再开启一个bash进行操作

\  取消特殊符号的特殊意义,进行转义操作
echo $RMB

echo "$RMB"

echo '$RMB'  # 单引号也可以实现转义操作

| 管道符,把原来应该输出到屏幕上(标准输出)的内容输出到管道中,管道符会把标准输出转成标准输入,不是所有命令都能从标准输入(管道中)中接收参数,因此可以借助xargs将标准输入转成命令行参数


{} 批量创建文件, 界定变量边界, 类似于Python中的 f'{name}' 格式化输出

touch {a..s}.txt
touch {a..c}{1..2}.txt

num=30
echo ${num}RMB 

'' 由单引号括起来的字符都作为普通字符出现。特殊字符用单引号括起来以后, 也会失去原有意义,而只作为普通字符解释.
"" 双引号的作用于单引号类似, 区别在于它没有那么严格, 单引号告诉 shell 忽略所有的特殊字符,而双引号只要求忽略大多数字符。具体来说，括在双引号中的三种特殊字符不被忽略：$，\和``，即双引号会解释字符串的特别意义，而单引号则直接使用字符串。

; 命令连接符号, 所有的命令都会运行不管是否运行成功

&& 命令连接符号,只有&&前面的命令运行成功,才会运行后面的命令

|| 命令连接符号, 只有&&前面的命令运行失败, 才会运行后面的命令

? bash解释器中?表示匹配任意一个字符

ls ?.txt # 匹配到文件名只有一个字符的txt
ls ??.txt # 匹配到文件名有2个哦字符的txt

type 命令 #查看命令类型

# 命令优先级
别名：alias
    复合命令：if while for等命令
        函数
            内置命令
                hash
                    $PATH
                        error：comand not found


删除变量
a = 10 
echo $a

unset a
echo $a

### 数据类型
age=18  # 整形
salary=53.7  # 浮点型

name='shell' #字符串类型, 如果想让字符串中包含特殊字符, 就是用单引号,普通字符串使用单引号和双引号都可以
name="bash"

求变量的长度
${#变量名} 和 echo ${变量名}|wc -L 和 awk


### 打印输出

printf "hello\n"